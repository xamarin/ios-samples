// This file has been autogenerated from a class added in the UI designer.
using System;
using System.Collections.Generic;
using AVFoundation;
using CoreFoundation;
using CoreMedia;
using Foundation;
using UIKit;

namespace AVCompositionDebugVieweriOS
{
	public partial class APLViewController : UIViewController
	{
		/* nanoseconds per second */
		private const int NSEC_PER_SEC = 1000000000;
		public static NSString AVCustomEditPlayerViewControllerStatusObservationContext = new NSString ("AVCustomEditPlayerViewControllerStatusObservationContext");
		public static NSString AVCustomEditPlayerViewControllerRateObservationContext = new NSString ("AVCustomEditPlayerViewControllerRateObservationContext");
		private NSObject playToEndObserver;
		private bool seekToZeroBeforePlaying;
		private float transitionDuration;
		private float playRateToRestore;
		private int transitionType;
		private NSObject timeObserver;

		public bool IsPlaying { get; private set; }

		public AVPlayer Player { get; set; }

		public AVPlayerItem PlayerItem { get; set; }

		public List<AVAsset> Clips { get; set; }

		public List<NSValue> ClipTimeRanges { get; set; }

		private SimpleEditor Editor { get; set; }

		private bool ScrubIsInFlight { get; set; }

		private CMTime PlayerItemDuration {
			get {
				AVPlayerItem playerItem = Player.CurrentItem;
				CMTime itemDuration = CMTime.Zero;
				if (Player.Status == AVPlayerStatus.ReadyToPlay) {
					itemDuration = playerItem.Duration;
				}

				return itemDuration;
			}
		}

		public APLViewController (IntPtr handle) : base (handle)
		{
			Clips = new List<AVAsset> ();
			ClipTimeRanges = new List<NSValue> ();
		}

		public override void ViewDidLoad ()
		{
			base.ViewDidLoad ();
			
			Editor = new SimpleEditor ();

			transitionType = 1;
			transitionDuration = 2.0f;
			
			SetupEditingAndPlayback ();
			SetupScrubber ();
			playPauseButton.Clicked += PlayButtonClicked;
		}

		private void SetupScrubber ()
		{
			scrubber.Value = 0.0f;
			scrubber.ValueChanged += OnScrubberValueChanged;
			scrubber.TouchDragInside += BeginScrubbing;
			scrubber.TouchUpInside += EndScrubbing;
			scrubber.TouchUpOutside += EndScrubbing;
		}

		private void BeginScrubbing (object sender, EventArgs e)
		{
			seekToZeroBeforePlaying = false;
			playRateToRestore = Player.Rate;

			RemoveTimeObserverFromPlayer ();

			if (IsPlaying) {
				Player.Pause ();
			}
		}

		private void EndScrubbing (object sender, EventArgs e)
		{
			if (ScrubIsInFlight) {
				ScrubToSliderValue (scrubber.Value);
			}

			Player.Rate = playRateToRestore;
			playRateToRestore = 0f;

			AddTimeObserverToPlayer ();

			if (IsPlaying) {
				Player.Play ();
			}
		}

		private void OnScrubberValueChanged (object sender, EventArgs e)
		{
			ScrubToSliderValue (scrubber.Value);
		}

		private void HandleScrubToSliderValueComplete (bool finished)
		{
			ScrubIsInFlight = false;
			UpdateTimeLabel ();
		}

		private void ScrubToSliderValue (float currentValue)
		{
			double duration = PlayerItemDuration.Seconds;

			float width = (float)scrubber.Bounds.Width;
			double time = duration * currentValue;
			double tolerance = 1.0f * duration / width;

			ScrubIsInFlight = true;

			Player.Seek (CMTime.FromSeconds (time, NSEC_PER_SEC), 
			             CMTime.FromSeconds (tolerance, NSEC_PER_SEC),
			             CMTime.FromSeconds (tolerance, NSEC_PER_SEC),
			             HandleScrubToSliderValueComplete
			);
		}

		public override void ViewDidAppear (bool animated)
		{
			base.ViewDidAppear (animated);

			if (Player == null) {
				seekToZeroBeforePlaying = false;
				Player = new AVPlayer ();
				playerView.Player = Player;
				compositionDebugView.Player = Player;
			}

			AddTimeObserverToPlayer ();

			Editor.BuildCompositionObjects (true);
			SynchronizeWithEditor ();

			// Set our AVPlayer and all composition objects on the AVCompositionDebugView
			compositionDebugView.Player = Player;
			compositionDebugView.SynchronizeToCompositoin (Editor.Composition, Editor.VideoComposition, Editor.AudioMix);
			compositionDebugView.SetNeedsDisplay ();
		}

		public override void ViewWillDisappear (bool animated)
		{
			ViewWillDisappear (animated);
			Player.Pause ();
			RemoveTimeObserverFromPlayer ();
		}

		private void SetupEditingAndPlayback ()
		{
			string path1 = NSBundle.MainBundle.PathForResource ("sample_clip1", "m4v");
			string path2 = NSBundle.MainBundle.PathForResource ("sample_clip2", "mov");

			var asset1 = AVUrlAsset.FromUrl (new NSUrl (path1, false)) as AVUrlAsset;
			var asset2 = AVUrlAsset.FromUrl (new NSUrl (path2, false)) as AVUrlAsset;

			var dispatchGroup = DispatchGroup.Create ();

			string[] assetKeysToLoadandTest = new string[] {
				"tracks",
				"duration",
				"composable"
			};

			LoadAsset (asset1, assetKeysToLoadandTest, dispatchGroup);
			LoadAsset (asset2, assetKeysToLoadandTest, dispatchGroup);

			dispatchGroup.DispatchAsync (DispatchQueue.MainQueue, SynchronizeWithEditor);
		}

		private void LoadAsset (AVUrlAsset asset, string[] assetKeysToLoadandTest, DispatchGroup dispatchGroup)
		{
			dispatchGroup.Enter ();
			asset.LoadValuesAsynchronously (assetKeysToLoadandTest, () => {
				foreach (string key in assetKeysToLoadandTest) {
					NSError error;
					if (asset.StatusOfValue (key, out error) == AVKeyValueStatus.Failed) {
						Console.Error.WriteLine ("Key value loading failed for key" + key + " with error: " + error.ToString ());
						dispatchGroup.Leave ();
					}
				}

				if (!asset.Composable) {
					Console.Error.WriteLine ("Asset is not composable");
					dispatchGroup.Leave ();
				}

				Clips.Add (asset);
				CMTimeRange timeRange = new CMTimeRange () {
					Start = CMTime.FromSeconds (0, 1),
					Duration = CMTime.FromSeconds (5, 1)
				};

				ClipTimeRanges.Add (NSValue.FromCMTimeRange (timeRange));
				dispatchGroup.Leave ();
			});
		}

		private void SynchronizeEditorClipTimeRangesWithOurClipTimeRanges ()
		{
			var validClipTimeRanges = new List<NSValue> ();
			foreach (NSValue timeRange in ClipTimeRanges) {
				if (timeRange != null) {
					validClipTimeRanges.Add (timeRange);
				}
			}

			Editor.ClipTimeRanges = ClipTimeRanges;
		}

		private void SynchronizeWithEditor ()
		{
			SynchronizeEditorClipsWithOurClips ();
			SynchronizeEditorClipTimeRangesWithOurClipTimeRanges ();

			Editor.TransitionDuration = CMTime.FromSeconds (transitionDuration, 600);
			Editor.TransitionType = transitionType;

			Editor.BuildCompositionObjects (true);
			SynchronizePlayerWithEditor ();

			compositionDebugView.Player = Player;
			compositionDebugView.SynchronizeToCompositoin (Editor.Composition, Editor.VideoComposition, Editor.AudioMix);
			compositionDebugView.SetNeedsDisplay ();
		}

		public override void ObserveValue (NSString keyPath, NSObject ofObject, NSDictionary change, IntPtr context)
		{
			if (context == AVCustomEditPlayerViewControllerRateObservationContext.Handle) {
				float newRate = ((NSNumber)change.ObjectForKey (NSObject.ChangeNewKey)).FloatValue;
				var oldRateNum = change.ObjectForKey (NSObject.ChangeOldKey);
				if (oldRateNum.GetType () == typeof(NSNumber) && newRate != ((NSNumber)oldRateNum).FloatValue) {
					UpdatePlayPauseButton ();
					UpdateScrubber ();
					UpdateTimeLabel ();
				}
			} else if (context == AVCustomEditPlayerViewControllerStatusObservationContext.Handle) {
				AVPlayerItem playerItem = ofObject as AVPlayerItem;
				if (playerItem.Status == AVPlayerItemStatus.ReadyToPlay) {
					AddTimeObserverToPlayer ();
				} else if (playerItem.Status == AVPlayerItemStatus.Failed) {
					Console.WriteLine (playerItem.Error.LocalizedDescription);				
				}
			} else {
				base.ObserveValue (keyPath, ofObject, change, context);
			}
		}

		private void UpdatePlayPauseButton ()
		{
			var style = IsPlaying ? UIBarButtonSystemItem.Pause : UIBarButtonSystemItem.Play;
			var newPlayPauseButton = new UIBarButtonItem (style, PlayButtonClicked);

			var items = toolbar.Items;
			items [0] = newPlayPauseButton;
			toolbar.SetItems (items, false);

			playPauseButton = newPlayPauseButton;
		}

		private void AddTimeObserverToPlayer ()
		{
			if (timeObserver != null) {
				Console.WriteLine ("timeObserver != null");
				return;
			}

			if (Player == null) {
				Console.WriteLine ("Player == null");
				return;
			}

			if (Player.CurrentItem == null) {
				Console.WriteLine ("Player.CurrentItem == null");
				return;
			}

			if (Player.CurrentItem.Status != AVPlayerItemStatus.ReadyToPlay) {
				Console.WriteLine ("Player.CurrentItem.Status != AVPlayerItemStatus.ReadyToPlay");
				return;
			}

			double duration = PlayerItemDuration.Seconds;

			if (duration != 0) {
				float width = (float)scrubber.Bounds.Width;
				double interval = 0.5 * duration / width;

				if (interval > 1.0) {
					interval = 1.0;
				}

				timeObserver = Player.AddPeriodicTimeObserver (CMTime.FromSeconds (interval, NSEC_PER_SEC), 
				                                               DispatchQueue.MainQueue,
				                                               delegate {	
					UpdateScrubber ();
					UpdateTimeLabel ();
				});
			}
		}

		private void RemoveTimeObserverFromPlayer ()
		{
			if (timeObserver != null)
				Player.RemoveTimeObserver (timeObserver);

			timeObserver = null;
		}

		private void UpdateTimeLabel ()
		{
			double secondes = Player.CurrentTime.Seconds;
			Console.WriteLine (secondes);
			if (double.IsInfinity (secondes)) 
				secondes = 0;

			int secondsInt = (int)Math.Round (secondes);
			int minutes = secondsInt / 60;
			secondsInt -= minutes * 60;

			this.currentTimeLabel.TextColor = UIColor.White;
			this.currentTimeLabel.TextAlignment = UITextAlignment.Center;
			this.currentTimeLabel.Text = string.Format ("{0} : {1}", minutes, secondsInt);
		}

		private void UpdateScrubber ()
		{
			double duration = PlayerItemDuration.Seconds;
			if (!double.IsInfinity (duration)) {
				double time = Player.CurrentTime.Seconds;
				scrubber.Value = (float)(time / duration);
			} else 
				scrubber.Value = 0.0f;
		}

		private void SynchronizePlayerWithEditor ()
		{
			if (Player == null) 
				return;

			AVPlayerItem playerItem = Editor.PlayerItem;

			if (PlayerItem != playerItem) {
				if (PlayerItem != null) {
					PlayerItem.RemoveObserver (this, new NSString ("status"));
					playToEndObserver.Dispose ();
					playToEndObserver = null;
				}

				PlayerItem = playerItem;

				if (PlayerItem != null) {
					PlayerItem.SeekingWaitsForVideoCompositionRendering = true;
					PlayerItem.AddObserver (this, new NSString ("status"), NSKeyValueObservingOptions.New | NSKeyValueObservingOptions.Initial, 
					                        AVCustomEditPlayerViewControllerStatusObservationContext.Handle);

					playToEndObserver = AVPlayerItem.Notifications.ObserveDidPlayToEndTime (PlayToEndNotificationHandler);
				}

				Player.ReplaceCurrentItemWithPlayerItem (playerItem);
			}
		}

		private void PlayToEndNotificationHandler (object sender, NSNotificationEventArgs args)
		{
			IsPlaying = false;
			seekToZeroBeforePlaying = true;

			UpdatePlayPauseButton ();
		}

		private void PlayButtonClicked (object sender, EventArgs e)
		{
			IsPlaying = !IsPlaying;

			if (IsPlaying) {
				if (seekToZeroBeforePlaying) {
					Player.Seek (CMTime.Zero, HandleVideoPlayingComplete);
				} else {
					Player.Play ();
				}
			} else {
				Player.Pause ();
			}

			UpdatePlayPauseButton ();
		}

		private void HandleVideoPlayingComplete (bool finished)
		{
			if (finished) {
				Console.WriteLine ("Seeked to Zero");
				seekToZeroBeforePlaying = false;
				Player.Play ();
			} else 
				Console.WriteLine ("Seek to Zero Failed");
		}

		private void SynchronizeEditorClipsWithOurClips ()
		{
			List<AVAsset> validClips = new List<AVAsset> ();
			foreach (AVAsset asset in Clips) {
				if (asset != null) 
					validClips.Add (asset);
			}

			Editor.Clips = validClips;
		}
	}
}
