// This file has been autogenerated from a class added in the UI designer.

using System;

using CoreAnimation;
using CoreGraphics;
using Foundation;
using Metal;
using ObjCRuntime;
using UIKit;

namespace MetalBasic3D {
	[Register ("GameView")]
	public class GameView : UIView {
		[Export ("layerClass")]
		public static Class LayerClass ()
		{
			return new Class (typeof (CAMetalLayer));
		}

		bool layerSizeDidUpdate;

		IMTLTexture depthTex;
#pragma warning disable 649
		IMTLTexture stencilTex;
#pragma warning restore 649
		IMTLTexture msaaTex;

		CAMetalLayer metalLayer;
		IMTLDevice device;
		MTLRenderPassDescriptor renderPassDescriptor;
		CGSize drawableSize;

		public MTLPixelFormat DepthPixelFormat { get; set; }

		public MTLPixelFormat StencilPixelFormat { get; set; }

		public nuint SampleCount { get; set; }

		public IGameView Delegate { get; set; }

		public override nfloat ContentScaleFactor {
			get {
				return base.ContentScaleFactor;
			}
			set {
				base.ContentScaleFactor = value;
				layerSizeDidUpdate = true;
			}
		}

		public GameView (IntPtr handle) : base (handle)
		{
			Opaque = true;
			BackgroundColor = UIColor.Clear;

			metalLayer = (CAMetalLayer) Layer;
			ContentScaleFactor = UIScreen.MainScreen.Scale;
			metalLayer.PresentsWithTransaction = false;
			metalLayer.DrawsAsynchronously = true;

			device = MTLDevice.SystemDefault;

			metalLayer.Device = device;
			metalLayer.PixelFormat = MTLPixelFormat.BGRA8Unorm;
			metalLayer.FramebufferOnly = true;

			drawableSize = Bounds.Size;
		}

		public override void LayoutSubviews ()
		{
			base.LayoutSubviews ();
			layerSizeDidUpdate = true;
		}

		public MTLRenderPassDescriptor GetRenderPassDescriptor (ICAMetalDrawable drawable)
		{
			if (drawable == null) {
				Console.WriteLine ("ERROR: Failed to get a drawable!");
				return null;
			}

			SetupRenderPassDescriptorForTexture (drawable.Texture);
			return renderPassDescriptor;
		}

		public ICAMetalDrawable GetNextDrawable ()
		{
			ICAMetalDrawable currentDrawable = null;

			while (currentDrawable == null) {
				currentDrawable = metalLayer.NextDrawable ();
				if (currentDrawable == null)
					Console.WriteLine ("CurrentDrawable is null");
			}

			return currentDrawable;
		}

		public void Display ()
		{
			if (layerSizeDidUpdate) {
				drawableSize = Bounds.Size;
				drawableSize.Width *= ContentScaleFactor;
				drawableSize.Height *= ContentScaleFactor;
				metalLayer.DrawableSize = drawableSize;

				Delegate.Reshape (this);
				layerSizeDidUpdate = false;
			}

			Delegate.Render (this);
		}

		void SetupRenderPassDescriptorForTexture (IMTLTexture texture)
		{
			if (renderPassDescriptor == null)
				renderPassDescriptor = new MTLRenderPassDescriptor ();

			MTLRenderPassColorAttachmentDescriptor colorAttachment = renderPassDescriptor.ColorAttachments [0];
			colorAttachment.Texture = texture;
			colorAttachment.LoadAction = MTLLoadAction.Clear;
			colorAttachment.ClearColor = new MTLClearColor (0.65f, 0.65f, 0.65f, 1.0f);

			if (SampleCount > 1) {
				if (msaaTex == null || NeedUpdate (texture, msaaTex)) {
					var desc = MTLTextureDescriptor.CreateTexture2DDescriptor (MTLPixelFormat.BGRA8Unorm, texture.Width, texture.Height, false);
					desc.TextureType = MTLTextureType.k2DMultisample;
					desc.SampleCount = SampleCount;
					msaaTex = device.CreateTexture (desc);
				}

				colorAttachment.Texture = msaaTex;
				colorAttachment.ResolveTexture = texture;

				// set store action to resolve in this case
				colorAttachment.StoreAction = MTLStoreAction.MultisampleResolve;
			} else {
				colorAttachment.StoreAction = MTLStoreAction.Store;
			}

			if (DepthPixelFormat != MTLPixelFormat.Invalid) {
				if (depthTex == null || NeedUpdate (texture, depthTex)) {
					var desc = MTLTextureDescriptor.CreateTexture2DDescriptor (DepthPixelFormat, texture.Width, texture.Height, false);
					desc.TextureType = (SampleCount > 1) ? MTLTextureType.k2DMultisample : MTLTextureType.k2D;
					desc.SampleCount = SampleCount;
					depthTex = device.CreateTexture (desc);

					MTLRenderPassDepthAttachmentDescriptor depthAttachment = renderPassDescriptor.DepthAttachment;
					depthAttachment.Texture = depthTex;
					depthAttachment.LoadAction = MTLLoadAction.Clear;
					depthAttachment.StoreAction = MTLStoreAction.DontCare;
					depthAttachment.ClearDepth = 1.0;
				}
			}

			if (StencilPixelFormat != MTLPixelFormat.Invalid) {
				if (stencilTex == null || NeedUpdate (texture, stencilTex)) {
					var desc = MTLTextureDescriptor.CreateTexture2DDescriptor (StencilPixelFormat, texture.Width, texture.Height, false);
					desc.TextureType = (SampleCount > 1) ? MTLTextureType.k2DMultisample : MTLTextureType.k2D;
					desc.SampleCount = SampleCount;
					depthTex = device.CreateTexture (desc);

					MTLRenderPassStencilAttachmentDescriptor stencilAttachment = renderPassDescriptor.StencilAttachment;
					stencilAttachment.Texture = depthTex;
					stencilAttachment.LoadAction = MTLLoadAction.Clear;
					stencilAttachment.StoreAction = MTLStoreAction.DontCare;
					stencilAttachment.ClearStencil = 1;
				}
			}
		}

		bool NeedUpdate (IMTLTexture texture, IMTLTexture textureToCompare)
		{
			bool doUpdate = false;
			if (msaaTex != null)
				doUpdate = (textureToCompare.Width != texture.Width) || (textureToCompare.Height != texture.Height) || (textureToCompare.SampleCount != SampleCount);

			return doUpdate;
		}
	}
}
