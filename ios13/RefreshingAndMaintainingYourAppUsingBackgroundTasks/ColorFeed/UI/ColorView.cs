// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Threading;
using System.Threading.Tasks;
using CoreGraphics;
using CoreMedia;
using Foundation;
using UIKit;

namespace ColorFeed
{
	public partial class ColorView : UIView
	{
		UIImageView imageView;
		CancellationTokenSource cancellationTokenSource;

		Post post;
		public Post Post {
			get => post;
			set {
				if (post == value)
					return;

				post = value;
				UpdateContents (true);
			}
		}

		public ColorView (IntPtr handle) : base (handle)
		{
		}

		public override void AwakeFromNib ()
		{
			imageView = new UIImageView ();
			AddSubview (imageView);
			cancellationTokenSource = new CancellationTokenSource ();
		}

		void UpdateContents (bool resetExisting = false)
		{
			cancellationTokenSource.Cancel ();
			cancellationTokenSource = new CancellationTokenSource ();

			if (resetExisting || post == null)
				SetImage (null, false);

			if (post == null)
				return;

			var rect = Bounds;

			Task.Factory.StartNew (async () => {
				if (cancellationTokenSource.IsCancellationRequested)
					return;
#if DEBUG
				UIApplication.CheckForIllegalCrossThreadCalls = false;
#endif
				var image = await Render (rect);
#if DEBUG
				UIApplication.CheckForIllegalCrossThreadCalls = true;
#endif
				InvokeOnMainThread (() => {
					if (cancellationTokenSource.IsCancellationRequested)
						return;

					imageView.Image = image;
				});
			}, cancellationTokenSource.Token);


		}

		void SetImage (UIImage image, bool animated)
		{
			if (!animated) {
				imageView.Image = image;
				return;
			}

			var options = UIViewAnimationOptions.TransitionCrossDissolve | UIViewAnimationOptions.BeginFromCurrentState | UIViewAnimationOptions.AllowUserInteraction;
			Transition (imageView, 0.2, options, () => imageView.Image = image, null);
		}

		public override void LayoutSubviews ()
		{
			base.LayoutSubviews ();
			imageView.Frame = Bounds;
			UpdateContents ();
		}

		Task<UIImage> Render (CGRect rect)
		{
			return Task<UIImage>.Factory.StartNew (() => new UIGraphicsImageRenderer (rect.Size).CreateImage (RenderImage));

			void RenderImage (UIGraphicsImageRendererContext _)
			{
				var context = UIGraphics.GetCurrentContext ();

				var gradient = new CGGradient (CGColorSpace.CreateDeviceRGB (),
					new [] { post.FirstColor.ToUIColor ().CGColor, post.SecondColor.ToUIColor ().CGColor },
					new nfloat [] { 0, 1 });
				var angle = post.GradientDirection / 360;

				var startX = Math.Pow (Math.Sin (2 * Math.PI * (.75 + angle) / 2), 2) * rect.Width;
				var startY = Math.Pow (Math.Sin (2 * Math.PI * angle / 2), 2) * rect.Height;

				var endX = Math.Pow (Math.Sin (2 * Math.PI * (.25 + angle) / 2), 2) * rect.Width;
				var endY = Math.Pow (Math.Sin (2 * Math.PI * (.5 + angle) / 2), 2) * rect.Height;

				var options = CGGradientDrawingOptions.DrawsBeforeStartLocation | CGGradientDrawingOptions.DrawsAfterEndLocation;
				context.DrawLinearGradient (gradient, new CGPoint (startX, startY), new CGPoint (endX, endY), options);
				context.SetBlendMode (CGBlendMode.Screen);

				var text = post.Timestamp.ToString ("M/dd h:mm tt");
				var font = UIFont.SystemFontOfSize (48, UIFontWeight.Bold);
				var paragraphStyle = new NSMutableParagraphStyle { Alignment = UITextAlignment.Center };
				var drawBounds = rect.Inset (0, (rect.Height - font.PointSize) / 2);

				new NSAttributedString (text, new UIStringAttributes {
					ParagraphStyle = paragraphStyle,
					ForegroundColor = UIColor.FromWhiteAlpha (1, .5f),
					Font = font
				}).DrawString (drawBounds);
			}
		}
	}
}
