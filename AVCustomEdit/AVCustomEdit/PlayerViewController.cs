// This file has been autogenerated from a class added in the UI designer.

using System;
using System.Collections.Generic;

using MonoTouch.Foundation;
using MonoTouch.UIKit;
using MonoTouch.AVFoundation;
using MonoTouch.CoreFoundation;
using MonoTouch.CoreMedia;
using System.Threading.Tasks;
using System.IO;
using MonoTouch.AssetsLibrary;

namespace AVCustomEdit
{
	public partial class PlayerViewController : UIViewController
	{
		const int NSEC_PER_SEC = 1000000000;

		Boolean playing;
		Boolean scrubInFlight;
		Boolean seekToZeroBeforePlaying;
		float lastScrubSliderValue;
		float playRateToRestore;
		NSObject timeObserver;

		float transitionDuration;
		int transitionType;
		bool transitionsEnabled;

		NSObject observer;

		NSTimer progressTimer;

		public SimpleEditor Editor;
		public List<AVAsset> Clips;
		public List<NSValue> ClipTimeRanges;

		public AVPlayer Player;
		public AVPlayerItem PlayerItem;
		public UIPopoverController Popover;

		public static NSString StatusObservationContext = new NSString("AVCustomEditPlayerViewControllerStatusObservationContext");
		public static NSString RateObservationContext = new NSString ("AVCustomEditPlayerViewControllerRateObservationContext");

		double playerItemDuration {
			get {
				if (Player == null)
					return Double.PositiveInfinity;

				CMTime itemDuration = CMTime.Invalid;
				AVPlayerItem playerItem = Player.CurrentItem;

				if (Player.Status == AVPlayerStatus.ReadyToPlay) {
					itemDuration = playerItem.Duration;
				}

				return itemDuration.Seconds;
			}
		}

		public PlayerViewController (IntPtr handle) : base (handle)
		{

		}

		public override void ViewDidLoad ()
		{
			base.ViewDidLoad ();
		
			gestureRecognizer.ShouldReceiveTouch = ShouldReceiveTouch;
			gestureRecognizer.AddTarget (() => { HandleTapGesture (gestureRecognizer); });

			Editor = new SimpleEditor ();

			Clips = new List<AVAsset> ();
			ClipTimeRanges = new List<NSValue> ();

			transitionType = TransitionTypeController.DiagonalWipeTransition;
			transitionDuration = 2.0f;
			transitionsEnabled = true;

			updateScrubber ();
			updateTimeLabel ();

			setupEditingAndPlayback ();
		}

		public override void ViewDidAppear (bool animated)
		{
			base.ViewDidAppear (animated);

			if (Player == null) {
				seekToZeroBeforePlaying = false;
				Player = new AVPlayer ();
				Player.AddObserver (this, (NSString)"rate", NSKeyValueObservingOptions.Old | NSKeyValueObservingOptions.New, RateObservationContext.Handle);

				playerView.player = Player;
			}

			addTimeObserverToPlayer ();

			// Build AVComposition and AVVideoComposition objects for playback
			Editor.BuildCompositionObjects (true);
			synchronizePlayerWithEditor ();

		}

		public override void ViewWillDisappear (bool animated)
		{
			base.ViewWillDisappear (animated);
			Player.Pause();
			removeTimeObserverFromPlayer ();
		}


		public override void PrepareForSegue (UIStoryboardSegue segue, NSObject sender)
		{
			if (segue.Identifier == "Transition") {
				var transitionController = (segue.DestinationViewController as UINavigationController).TopViewController as TransitionTypeController;
				if (UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Pad)
					Popover = (segue as UIStoryboardPopoverSegue).PopoverController;

				transitionController.TransitionTypePicked = TransitionTypePicked;
				transitionController.CurrentTransition = transitionType;

				if (transitionType == TransitionTypeController.CrossDissolveTransition) {
					if (transitionController.CrossDissolveCell == null)
						transitionController.LoadView ();
					transitionController.CrossDissolveCell.Accessory = UITableViewCellAccessory.Checkmark;
				} else {
					if (transitionController.DiagonalWipeCell == null)
						transitionController.LoadView ();
					transitionController.DiagonalWipeCell.Accessory = UITableViewCellAccessory.Checkmark;
				}
			}
		}

		//Simple Editor
		void setupEditingAndPlayback()
		{
			var path1 = NSBundle.MainBundle.PathForResource ("sample_clip1", "m4v");
			var path2 = NSBundle.MainBundle.PathForResource ("sample_clip2", "mov");
			AVUrlAsset asset1 = AVUrlAsset.FromUrl (new NSUrl (path1, false)) as AVUrlAsset;
			AVUrlAsset asset2 = AVUrlAsset.FromUrl (new NSUrl (path2, false)) as AVUrlAsset;

			DispatchGroup dispatchGroup = DispatchGroup.Create ();

			string[] assetKeys = new string[] {
				"tracks",
				"duration",
				"composable"
			};

			loadAsset (asset1, assetKeys, dispatchGroup);
			loadAsset (asset2, assetKeys, dispatchGroup);

			// Wait until both assets are loaded
			dispatchGroup.Wait (DispatchTime.Forever);
			InvokeOnMainThread(delegate{
				synchronizeWithEditor();
			});
			
		}

		void loadAsset(AVAsset asset, string[] assetKeysToLoad, DispatchGroup dispatchGroup)
		{
			dispatchGroup.Enter ();
			asset.LoadValuesAsynchronously (assetKeysToLoad, () => {
				foreach(var key in assetKeysToLoad)
				{
					NSError error;
					if(asset.StatusOfValue(key, out error) == AVKeyValueStatus.Failed)
					{
						Console.Error.WriteLine("Key value loading failed for key" + key + " with error: "+ error.ToString());
						dispatchGroup.Leave();
					}

				}
				if(!asset.Composable)
				{
					Console.Error.WriteLine("Asset is not composable");
					dispatchGroup.Leave();
				}
				lock (Clips) {
					Clips.Add(asset);
					ClipTimeRanges.Add(NSValue.FromCMTimeRange(new CMTimeRange(){
						Start =  CMTime.FromSeconds(0, 1),
						Duration =  CMTime.FromSeconds(5,1)
					}));
				}
				dispatchGroup.Leave();
			});
		}

		void synchronizePlayerWithEditor()
		{
			if (Player == null)
				return;

			AVPlayerItem playerItem = Editor.PlayerItem;
			var status = (NSString)"status";

			if (this.PlayerItem != playerItem) {
				if (PlayerItem != null) {
					PlayerItem.RemoveObserver (this, status);
					NSNotificationCenter.DefaultCenter.RemoveObserver (observer, AVPlayerItem.DidPlayToEndTimeNotification, PlayerItem);
				}

				PlayerItem = playerItem;

				if (PlayerItem != null) {
					this.PlayerItem.SeekingWaitsForVideoCompositionRendering = true;
					this.PlayerItem.AddObserver (this, status, NSKeyValueObservingOptions.New| 
						NSKeyValueObservingOptions.Initial, StatusObservationContext.Handle);
					observer = NSNotificationCenter.DefaultCenter.AddObserver (AVPlayerItem.DidPlayToEndTimeNotification, (notification) => {
						Console.WriteLine("Seek Zero = true");
						seekToZeroBeforePlaying = true;
					}, playerItem);
					//NSNotificationCenter.DefaultCenter.AddObserver (this, new MonoTouch.ObjCRuntime.Selector ("playerItemEnded:"), AVPlayerItem.DidPlayToEndTimeNotification, playerItem);
				}

				Player.ReplaceCurrentItemWithPlayerItem (playerItem);
			}
		}
					
		[Export("playerItemEnded:")]
		void playerItemEnded (NSObject obj)
		{
			Console.WriteLine("Seek Zero = true");
			seekToZeroBeforePlaying = true;
		}

		void synchronizeWithEditor()
		{
			//Clips
			synchronizeEditorClips ();
			synchronizeEditorClipTimeRanges ();

			//Transitions
			if (transitionsEnabled) {
				Editor.TransitionDuration = CMTime.FromSeconds (transitionDuration, 600);
				Editor.TransitionType = transitionType;

			} else {
				Editor.TransitionDuration = CMTime.Invalid;
			}

			Editor.BuildCompositionObjects (true);
			synchronizePlayerWithEditor ();
		}

		void synchronizeEditorClips()
		{
			List<AVAsset> validClips = new List<AVAsset> ();
			foreach (var asset in Clips) {
				if (asset != null)
					validClips.Add (asset);
			}

			Editor.Clips = validClips;
		}

		void synchronizeEditorClipTimeRanges()
		{
			List<NSValue> validClipTimeRanges = new List<NSValue> ();
			foreach (var timeRange in ClipTimeRanges) {
				if (timeRange != null)
					validClipTimeRanges.Add (timeRange);
			}

			Editor.ClipTimeRanges = validClipTimeRanges;
		}

		//Utilities
		void addTimeObserverToPlayer()
		{
			if (timeObserver != null) {
				return;
			}

			if (Player == null)
				return;

			if (Player.CurrentItem == null)
				return;

			if (Player.CurrentItem.Status != AVPlayerItemStatus.ReadyToPlay)
				return;

			double duration = playerItemDuration;

			if (!Double.IsInfinity (duration)) {
				float width = scrubber.Bounds.Width;
				double interval = 0.5 * duration / width;

				if (interval > 1.0)
					interval = 1.0;
				timeObserver = Player.AddPeriodicTimeObserver (CMTime.FromSeconds (interval, NSEC_PER_SEC), DispatchQueue.MainQueue, delegate {
					updateScrubber();
					updateTimeLabel();
				});
			}

		}

		void removeTimeObserverFromPlayer()
		{
			if (timeObserver != null) {
				Player.RemoveTimeObserver (timeObserver);
				timeObserver = null;
			}
		}

		public override void ObserveValue (NSString keyPath, NSObject ofObject, NSDictionary change, IntPtr context)
		{
			if (context == RateObservationContext.Handle) {
				//TODO: need debug here.
				float newRate = ((NSNumber)change.ObjectForKey (NSObject.ChangeNewKey)).FloatValue;
				var oldRateNum = change.ObjectForKey (NSObject.ChangeOldKey);
				if (oldRateNum.GetType () == typeof(NSNumber) && newRate != ((NSNumber)oldRateNum).FloatValue) {
					playing = (newRate != 0.0f || playRateToRestore != 0.0f);
					updatePlayPauseButton ();
					updateScrubber ();
					updateTimeLabel ();
				}
			} else if (context == StatusObservationContext.Handle) {
				AVPlayerItem playerItem = ofObject as AVPlayerItem;
				if (playerItem.Status == AVPlayerItemStatus.ReadyToPlay) {
					/* Once the AVPlayerItem becomes ready to play, i.e.
					   [playerItem status] == AVPlayerItemStatusReadyToPlay,
					   its duration can be fetched from the item. */
					addTimeObserverToPlayer ();
				} else if (playerItem.Status == AVPlayerItemStatus.Failed) {
					reportError (playerItem.Error);				
				}
			} else {
				base.ObserveValue (keyPath, ofObject, change, context);
			}
		}

		void updatePlayPauseButton()
		{
			var style = playing ? UIBarButtonSystemItem.Pause : UIBarButtonSystemItem.Play;
			var newPlayPauseButton = new UIBarButtonItem (style, (s, e) => { togglePlayPause (s as UIBarButtonItem); });

			var items = toolBar.Items;
			items [0] = newPlayPauseButton;
			toolBar.SetItems (items, false);

			playPauseButton = newPlayPauseButton;
		}

		void updateTimeLabel()
		{
			if (Player == null)
				return;

			var seconds = Player.CurrentTime.Seconds;
			Console.WriteLine (seconds);
			if (double.IsInfinity(seconds))
				seconds = 0;

			int secondsInt =(int) Math.Round (seconds);
			int minutes = secondsInt / 60;
			secondsInt -= minutes * 60;

			currentTimeLabel.TextColor = UIColor.White;
			currentTimeLabel.TextAlignment = UITextAlignment.Center;
			currentTimeLabel.Text = string.Format ("{0} : {1}", minutes, secondsInt);

		}

		void updateScrubber()
		{
			double duration = playerItemDuration;
			if (!double.IsInfinity(duration)) {
				double time = Player.CurrentTime.Seconds;
				scrubber.Value = (float)(time / duration);
			} else {
				scrubber.Value = 0.0f;
			}
		}

		void updateProgress(NSTimer timer)
		{
			var session = timer.UserInfo as AVAssetExportSession;
			if (session.Status == AVAssetExportSessionStatus.Exporting) 
				exportProgressView.Progress = session.Progress;
		}

		void reportError(NSError error)
		{
			DispatchQueue.MainQueue.DispatchAsync (() => {
				if (error == null)
					return;

				new UIAlertView (error.LocalizedDescription, error.DebugDescription, null, "OK", null).Show ();
			});
		}

		partial void togglePlayPause (UIBarButtonItem sender)
		{
			playing = !playing;
			if (playing) {
				if (seekToZeroBeforePlaying) {
					Player.Seek (CMTime.Zero);
					seekToZeroBeforePlaying = false;
//					player.Seek (CMTime.Zero, delegate(bool finished) {
//						if(finished){
//							Console.WriteLine ("Seeked to Zero");
//							this.seekToZeroBeforePlaying = false;
//							this.player.Play();
//						}
//						else
//							Console.WriteLine ("Seek to Zero Failed");
//					});
				}
				Player.Play();
			} else {
				Player.Pause();
			}
		}

		partial void beginScrubbing (UISlider sender)
		{
			seekToZeroBeforePlaying = false;
			playRateToRestore = Player.Rate;
			Player.Rate = 0f;

			removeTimeObserverFromPlayer ();
		}

		async partial void endScrubbing (UISlider sender)
		{
			if (scrubInFlight)
				await scrubTo (lastScrubSliderValue);
			addTimeObserverToPlayer ();

			Player.Rate = playRateToRestore;
			playRateToRestore = 0f;
		}

		async partial void scrub (UISlider sender)
		{
			lastScrubSliderValue = scrubber.Value;

			if (!scrubInFlight)
				await scrubTo (lastScrubSliderValue);
		}

		async Task scrubTo (float sliderValue)
		{
			var duration = playerItemDuration;

			if (Double.IsInfinity (duration))
				return;

			var width = scrubber.Bounds.Width;

			var time = duration * sliderValue;
			var tolerance = 1f * duration / width;

			scrubInFlight = true;

			await Player.SeekAsync (CMTime.FromSeconds (time, NSEC_PER_SEC), CMTime.FromSeconds (tolerance, NSEC_PER_SEC), CMTime.FromSeconds (tolerance, NSEC_PER_SEC));

			scrubInFlight = false;
			updateTimeLabel ();
		}

		void HandleTapGesture (UITapGestureRecognizer tapGestureRecognizer)
		{
			toolBar.Hidden = !toolBar.Hidden;
			currentTimeLabel.Hidden = !currentTimeLabel.Hidden;
		}

		partial void exportToMovie (UIBarButtonItem sender)
		{
			exportProgressView.Hidden = false;

			Player.Pause ();
			playPauseButton.Enabled = false;
			transitionButton.Enabled = false;
			scrubber.Enabled = false;
			exportButton.Enabled = false;

			Editor.BuildCompositionObjects (false);

			var session = Editor.AssetExportSession (AVAssetExportSession.PresetMediumQuality);


			var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
			var filePath = Path.Combine (documents, "..", "tmp", "ExportedProject.mov");
			if (File.Exists (filePath))
				File.Delete (filePath);

			session.OutputUrl = NSUrl.FromFilename (filePath);
			session.OutputFileType = AVFileType.QuickTimeMovie;

			session.ExportAsynchronously (() => {
				DispatchQueue.MainQueue.DispatchAsync (() => {
					exportCompleted (session);
				});
			});

			progressTimer = NSTimer.CreateRepeatingTimer (0.5, () => updateProgress (progressTimer));
			NSRunLoop.Current.AddTimer (progressTimer, NSRunLoopMode.Default);
		}

		void exportCompleted (AVAssetExportSession session)
		{
			exportProgressView.Hidden = true;
			currentTimeLabel.Hidden = false;
			var outputUrl = session.OutputUrl;

			progressTimer.Invalidate ();
			progressTimer = null;

			if (session.Status != AVAssetExportSessionStatus.Completed) {
				Console.WriteLine ("exportSession error:{0}", session.Error.LocalizedDescription);
				reportError (session.Error);
				return;
			}

			exportProgressView.Progress = 1f;

			var library = new ALAssetsLibrary ();
			library.WriteVideoToSavedPhotosAlbum (outputUrl, (assetURL, error) => {
				if (error != null) {
					Console.WriteLine ("writeVideoToAssetsLibrary failed: {0}", error.LocalizedDescription);
					reportError (error);
				}
			});

			Player.Play ();
			playPauseButton.Enabled = true;
			transitionButton.Enabled = true;
			scrubber.Enabled = true;
			exportButton.Enabled = true;
		}

		bool ShouldReceiveTouch (UIGestureRecognizer gestureRecognizer, UITouch touch)
		{
			if (touch.View != View)
				return false;

			return true;
		}

		public void TransitionTypePicked (int transitionType)
		{
			this.transitionType = transitionType;

			synchronizeWithEditor ();

			if (UIDevice.CurrentDevice.UserInterfaceIdiom == UIUserInterfaceIdiom.Pad)
				Popover.Dismiss (true);
			else
				DismissViewController (true, null);
		}
	}
}
